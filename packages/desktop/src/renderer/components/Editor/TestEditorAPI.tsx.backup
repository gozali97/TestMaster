import { useState, useEffect } from 'react';
import { MonacoEditor } from './MonacoEditor';
import { StepEditor, TestStep } from './StepEditor';
import { VariableManager, Variable } from './VariableManager';
import { ApiService, TestCase } from '../../services/api.service';
import './TestEditor.css';

interface TestEditorAPIProps {
  projectId?: number;
  testCaseId?: number;
  onBack?: () => void;
}

export const TestEditorAPI = ({ projectId, testCaseId, onBack }: TestEditorAPIProps) => {
  const [view, setView] = useState<'visual' | 'script'>('visual');
  const [steps, setSteps] = useState<TestStep[]>([]);
  const [variables, setVariables] = useState<Variable[]>([]);
  const [scriptCode, setScriptCode] = useState('');
  const [editingStep, setEditingStep] = useState<TestStep | null>(null);
  const [showStepEditor, setShowStepEditor] = useState(false);
  const [showVariableManager, setShowVariableManager] = useState(false);
  const [testCase, setTestCase] = useState<TestCase | null>(null);
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [running, setRunning] = useState(false);
  const [executionResult, setExecutionResult] = useState<any>(null);
  const [error, setError] = useState('');

  // Load test case from API
  useEffect(() => {
    if (projectId && testCaseId) {
      loadTestCase();
    }
  }, [projectId, testCaseId]);

  // Update script when steps or variables change
  useEffect(() => {
    setScriptCode(generateScript(steps, variables));
  }, [steps, variables]);

  const loadTestCase = async () => {
    if (!projectId || !testCaseId) return;

    setLoading(true);
    setError('');

    const result = await ApiService.getTestCase(projectId, testCaseId);

    if (result.success && result.data) {
      setTestCase(result.data);
      setSteps(result.data.steps || []);
      setVariables(result.data.variables || []);
    } else {
      setError(result.error || 'Failed to load test case');
    }

    setLoading(false);
  };

  const saveTestCase = async () => {
    if (!projectId) {
      setError('Project ID is required');
      return;
    }

    setSaving(true);
    setError('');

    const data = {
      name: testCase?.name || 'Untitled Test',
      description: testCase?.description || '',
      steps,
      variables,
    };

    let result;
    if (testCaseId) {
      // Update existing test case
      result = await ApiService.updateTestCase(projectId, testCaseId, data);
    } else {
      // Create new test case
      result = await ApiService.createTestCase(projectId, data);
    }

    if (result.success && result.data) {
      setTestCase(result.data);
      alert('Test case saved successfully!');
    } else {
      setError(result.error || 'Failed to save test case');
      alert('Failed to save: ' + (result.error || 'Unknown error'));
    }

    setSaving(false);
  };

  function replaceVariables(text: string, vars: Variable[]): string {
    let result = text;
    vars.forEach(v => {
      result = result.replace(new RegExp(`\\{\\{${v.name}\\}\\}`, 'g'), v.value);
    });
    return result;
  }

  function generateScript(steps: TestStep[], vars: Variable[]): string {
    let script = `import { test, expect } from '@playwright/test';\n\n`;
    
    if (vars.length > 0) {
      script += `// Variables\n`;
      vars.forEach(v => {
        if (v.type === 'env') {
          script += `const ${v.name} = process.env.${v.name};\n`;
        } else if (v.type === 'string') {
          script += `const ${v.name} = '${v.value}';\n`;
        } else {
          script += `const ${v.name} = ${v.value};\n`;
        }
      });
      script += `\n`;
    }
    
    script += `test('${testCase?.name || 'Test Case'}', async ({ page }) => {\n`;
    
    steps.filter(s => s.enabled !== false).forEach(step => {
      const value = step.value ? replaceVariables(step.value, vars) : '';
      const locator = step.locator ? replaceVariables(step.locator, vars) : '';
      
      if (step.description) {
        script += `  // ${step.description}\n`;
      }
      
      switch (step.action) {
        case 'navigate':
          script += `  await page.goto('${value}');\n`;
          break;
        case 'click':
          script += `  await page.click('${locator}');\n`;
          break;
        case 'doubleClick':
          script += `  await page.dblclick('${locator}');\n`;
          break;
        case 'rightClick':
          script += `  await page.click('${locator}', { button: 'right' });\n`;
          break;
        case 'hover':
          script += `  await page.hover('${locator}');\n`;
          break;
        case 'type':
        case 'fill':
          script += `  await page.fill('${locator}', '${value}');\n`;
          break;
        case 'clear':
          script += `  await page.fill('${locator}', '');\n`;
          break;
        case 'press':
          script += `  await page.keyboard.press('${value}');\n`;
          break;
        case 'select':
          script += `  await page.selectOption('${locator}', '${value}');\n`;
          break;
        case 'check':
          script += `  await page.check('${locator}');\n`;
          break;
        case 'uncheck':
          script += `  await page.uncheck('${locator}');\n`;
          break;
        case 'upload':
          script += `  await page.setInputFiles('${locator}', '${value}');\n`;
          break;
        case 'wait':
          script += `  await page.waitForTimeout(${value});\n`;
          break;
        case 'waitForElement':
          script += `  await page.waitForSelector('${locator}', { state: '${step.waitCondition || 'visible'}' });\n`;
          break;
        case 'screenshot':
          script += `  await page.screenshot({ path: '${value}.png' });\n`;
          break;
        case 'assert':
          script += `  await expect(page.locator('${locator}')).toBeVisible();\n`;
          break;
        case 'assertText':
          script += `  await expect(page.locator('${locator}')).toHaveText('${value}');\n`;
          break;
        case 'assertValue':
          script += `  await expect(page.locator('${locator}')).toHaveValue('${value}');\n`;
          break;
        case 'executeScript':
          script += `  await page.evaluate(() => { ${value} });\n`;
          break;
        case 'refresh':
          script += `  await page.reload();\n`;
          break;
        case 'goBack':
          script += `  await page.goBack();\n`;
          break;
        case 'goForward':
          script += `  await page.goForward();\n`;
          break;
      }
    });
    
    script += `});\n`;
    return script;
  }

  const openAddStepEditor = () => {
    setEditingStep(null);
    setShowStepEditor(true);
  };

  const openEditStepEditor = (step: TestStep) => {
    setEditingStep(step);
    setShowStepEditor(true);
  };

  const handleSaveStep = (step: TestStep) => {
    if (editingStep) {
      const newSteps = steps.map(s => s.id === step.id ? step : s);
      setSteps(newSteps);
    } else {
      const newSteps = [...steps, step];
      setSteps(newSteps);
    }
    setShowStepEditor(false);
    setEditingStep(null);
  };

  const deleteStep = (id: string) => {
    const newSteps = steps.filter(s => s.id !== id);
    setSteps(newSteps);
  };

  const duplicateStep = (step: TestStep) => {
    const newStep = { ...step, id: Date.now().toString() };
    const index = steps.findIndex(s => s.id === step.id);
    const newSteps = [...steps.slice(0, index + 1), newStep, ...steps.slice(index + 1)];
    setSteps(newSteps);
  };

  const moveStep = (id: string, direction: 'up' | 'down') => {
    const index = steps.findIndex(s => s.id === id);
    if ((direction === 'up' && index === 0) || (direction === 'down' && index === steps.length - 1)) {
      return;
    }
    
    const newSteps = [...steps];
    const targetIndex = direction === 'up' ? index - 1 : index + 1;
    [newSteps[index], newSteps[targetIndex]] = [newSteps[targetIndex], newSteps[index]];
    setSteps(newSteps);
  };

  const toggleStepEnabled = (id: string) => {
    const newSteps = steps.map(s => 
      s.id === id ? { ...s, enabled: !s.enabled } : s
    );
    setSteps(newSteps);
  };

  const handleUpdateVariables = (newVars: Variable[]) => {
    setVariables(newVars);
  };

  const handleRunTest = async () => {
    if (!projectId || !testCaseId) {
      alert('Please save the test case before running');
      return;
    }

    // Make sure test is saved first
    if (steps.length === 0) {
      alert('Please add test steps before running');
      return;
    }

    setRunning(true);
    setExecutionResult(null);
    setError('');

    try {
      // Execute the test
      const result = await ApiService.executeTest(projectId, testCaseId);

      if (result.success && result.data) {
        setExecutionResult({
          runId: result.data.runId,
          status: result.data.status,
          message: result.data.message || 'Test execution started',
        });

        // Poll for results
        pollExecutionStatus(result.data.runId);
      } else {
        setError(result.error || 'Failed to start test execution');
      }
    } catch (err: any) {
      setError(err.message || 'Failed to run test');
    } finally {
      setRunning(false);
    }
  };

  const pollExecutionStatus = async (runId: number) => {
    const maxAttempts = 60; // Poll for 60 seconds
    let attempts = 0;

    const poll = setInterval(async () => {
      attempts++;

      if (attempts > maxAttempts) {
        clearInterval(poll);
        setExecutionResult((prev: any) => ({
          ...prev,
          status: 'TIMEOUT',
          message: 'Execution timeout - check backend logs',
        }));
        return;
      }

      const result = await ApiService.getExecutionResults(runId);

      if (result.success && result.data) {
        const status = result.data.status;

        setExecutionResult((prev: any) => ({
          ...prev,
          ...result.data,
        }));

        // Stop polling if execution is complete
        if (['PASSED', 'FAILED', 'ERROR', 'STOPPED'].includes(status)) {
          clearInterval(poll);
        }
      }
    }, 1000); // Poll every second
  };

  if (loading) {
    return (
      <div className="test-editor flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
          <p>Loading test case...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="test-editor">
      {onBack && (
        <div style={{ padding: '10px 20px', background: '#1e1e1e', borderBottom: '1px solid #3e3e42' }}>
          <button 
            onClick={onBack}
            style={{
              padding: '8px 16px',
              background: '#444',
              border: 'none',
              borderRadius: '4px',
              color: '#fff',
              cursor: 'pointer',
              fontSize: '14px'
            }}
          >
            â† Back to Tests
          </button>
        </div>
      )}
      
      {error && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
          {error}
        </div>
      )}

      <div className="editor-toolbar">
        <div className="view-toggle">
          <button
            className={view === 'visual' ? 'active' : ''}
            onClick={() => setView('visual')}
          >
            Visual Editor
          </button>
          <button
            className={view === 'script' ? 'active' : ''}
            onClick={() => setView('script')}
          >
            Script View
          </button>
        </div>
        <div className="actions">
          <button className="btn-primary" onClick={openAddStepEditor}>
            + Add Step
          </button>
          <button className="btn-secondary" onClick={() => setShowVariableManager(true)}>
            Variables ({variables.length})
          </button>
          <button 
            className="btn-success" 
            onClick={handleRunTest}
            disabled={running || !testCaseId}
            style={{
              background: running ? '#666' : '#28a745',
              cursor: running || !testCaseId ? 'not-allowed' : 'pointer',
            }}
          >
            {running ? 'â–¶ï¸ Running...' : 'â–¶ï¸ Run Test'}
          </button>
          <button 
            className="btn-primary" 
            onClick={saveTestCase}
            disabled={saving}
          >
            {saving ? 'Saving...' : 'ğŸ’¾ Save'}
          </button>
          <button 
            className="btn-secondary"
            onClick={loadTestCase}
            disabled={!testCaseId}
          >
            ğŸ”„ Reload
          </button>
        </div>
      </div>

      {executionResult && (
        <div 
          style={{
            margin: '10px 20px',
            padding: '16px',
            background: executionResult.status === 'PASSED' ? '#1e4620' : 
                       executionResult.status === 'FAILED' ? '#5a1e1e' :
                       executionResult.status === 'RUNNING' ? '#1e3a5a' : '#3a3a1a',
            border: `1px solid ${executionResult.status === 'PASSED' ? '#28a745' : 
                                 executionResult.status === 'FAILED' ? '#dc3545' :
                                 executionResult.status === 'RUNNING' ? '#007acc' : '#ffc107'}`,
            borderRadius: '4px',
            color: '#fff',
          }}
        >
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <div>
              <strong>Test Execution #{executionResult.runId}</strong>
              <span style={{ 
                marginLeft: '12px',
                padding: '4px 8px',
                background: 'rgba(0,0,0,0.2)',
                borderRadius: '3px',
                fontSize: '12px',
              }}>
                {executionResult.status}
              </span>
            </div>
            <button 
              onClick={() => setExecutionResult(null)}
              style={{
                background: 'transparent',
                border: 'none',
                color: '#fff',
                cursor: 'pointer',
                fontSize: '18px',
              }}
            >
              Ã—
            </button>
          </div>
          <p style={{ margin: '8px 0 0 0', fontSize: '14px' }}>
            {executionResult.message || 'Execution in progress...'}
          </p>
          {executionResult.passedTests !== undefined && (
            <div style={{ marginTop: '8px', fontSize: '13px' }}>
              Passed: {executionResult.passedTests} | Failed: {executionResult.failedTests || 0}
            </div>
          )}
        </div>
      )}

      {view === 'visual' ? (
        <div className="visual-editor">
          <div className="steps-list">
            {steps.map((step, index) => (
              <div 
                key={step.id} 
                className={`step-item ${step.enabled === false ? 'disabled' : ''}`}
              >
                <div className="step-number">{index + 1}</div>
                <div className="step-content" onClick={() => openEditStepEditor(step)}>
                  <div className="step-header">
                    <span className="step-action">{step.action}</span>
                    {step.enabled === false && <span className="disabled-badge">DISABLED</span>}
                  </div>
                  {step.description && <div className="step-description">{step.description}</div>}
                  {step.locator && <div className="step-locator">ğŸ¯ {step.locator}</div>}
                  {step.value && <div className="step-value">ğŸ“ {step.value}</div>}
                  {step.timeout && step.timeout !== 30000 && (
                    <div className="step-timeout">â±ï¸ {step.timeout}ms</div>
                  )}
                </div>
                <div className="step-actions">
                  <button 
                    className="btn-icon" 
                    onClick={(e) => { e.stopPropagation(); moveStep(step.id, 'up'); }}
                    disabled={index === 0}
                    title="Move up"
                  >
                    â¬†ï¸
                  </button>
                  <button 
                    className="btn-icon" 
                    onClick={(e) => { e.stopPropagation(); moveStep(step.id, 'down'); }}
                    disabled={index === steps.length - 1}
                    title="Move down"
                  >
                    â¬‡ï¸
                  </button>
                  <button 
                    className="btn-icon" 
                    onClick={(e) => { e.stopPropagation(); duplicateStep(step); }}
                    title="Duplicate"
                  >
                    ğŸ“‹
                  </button>
                  <button 
                    className="btn-icon" 
                    onClick={(e) => { e.stopPropagation(); toggleStepEnabled(step.id); }}
                    title={step.enabled === false ? 'Enable' : 'Disable'}
                  >
                    {step.enabled === false ? 'ğŸ‘ï¸' : 'ğŸš«'}
                  </button>
                  <button 
                    className="btn-icon btn-delete" 
                    onClick={(e) => { e.stopPropagation(); deleteStep(step.id); }}
                    title="Delete"
                  >
                    ğŸ—‘ï¸
                  </button>
                </div>
              </div>
            ))}
            {steps.length === 0 && (
              <div className="empty-state">
                <p>No steps added yet</p>
                <p>Click "Add Step" to create your first test step</p>
              </div>
            )}
          </div>
        </div>
      ) : (
        <div className="script-editor">
          <MonacoEditor
            value={scriptCode}
            onChange={setScriptCode}
            language="javascript"
            theme="vs-dark"
          />
        </div>
      )}

      {showStepEditor && (
        <StepEditor
          step={editingStep}
          onSave={handleSaveStep}
          onCancel={() => {
            setShowStepEditor(false);
            setEditingStep(null);
          }}
          variables={variables.map(v => v.name)}
        />
      )}

      {showVariableManager && (
        <VariableManager
          variables={variables}
          onUpdate={handleUpdateVariables}
          onClose={() => setShowVariableManager(false)}
        />
      )}
    </div>
  );
};
